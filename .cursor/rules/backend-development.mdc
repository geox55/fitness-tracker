---
description: Backend development rules for Fitness Tracker API
globs:
  - "packages/backend/**/*"
alwaysApply: false
---

# Backend Development Rules

## Reference Documentation

**Обязательно к прочтению:**
- Architecture: `docs/spec/02-architecture.md`
- API Spec: `docs/spec/03-api-specification.md`
- Testing: `docs/spec/04-testing-strategy.md`
- Role Guide: `docs/spec/roles/backend-developer.md`

## TypeScript & Code Quality Guidelines

### Basic Principles
- Use English for all code and documentation
- Always declare the type of each variable and function (parameters and return value)
- Avoid using `any` - create necessary types instead
- Use JSDoc to document public classes and methods
- Don't leave blank lines within a function
- One export per file

### Nomenclature
- Use PascalCase for classes
- Use camelCase for variables, functions, and methods
- Use kebab-case for file and directory names
- Use UPPERCASE for environment variables
- Avoid magic numbers - define constants
- Start each function with a verb
- Use verbs for boolean variables: `isLoading`, `hasError`, `canDelete`, etc.
- Use complete words instead of abbreviations (except standard: API, URL, etc.)

### Functions
- Write short functions with a single purpose (less than 20 instructions)
- Name functions with a verb:
  - Boolean returns: `isX`, `hasX`, `canX`
  - Actions: `executeX`, `saveX`, `createX`
- Avoid nesting blocks:
  - Early checks and returns
  - Extract to utility functions
- Use higher-order functions (map, filter, reduce) to avoid nesting
- Use arrow functions for simple functions (< 3 instructions)
- Use named functions for complex functions
- Use default parameter values instead of null/undefined checks
- Reduce function parameters using RO-RO pattern (object for input/output)
- Use a single level of abstraction

### Data & Classes
- Don't abuse primitive types - encapsulate in composite types
- Prefer immutability - use `readonly` for data that doesn't change
- Use `as const` for literals that don't change
- Follow SOLID principles
- Prefer composition over inheritance
- Declare interfaces to define contracts
- Write small classes:
  - Less than 200 instructions
  - Less than 10 public methods
  - Less than 10 properties

### Error Handling
- Use exceptions for unexpected errors
- If you catch an exception, it should be to:
  - Fix an expected problem
  - Add context
- Otherwise, use a global error handler
- **NEVER log raw error objects** - they may contain sensitive data (passwords, tokens, stack traces)
- **MANDATORY: Always use `sanitizeErrorForLogging` in catch blocks** - never log `err` directly:
```typescript
// ❌ BAD - Security risk
catch (err) {
  req.log.error(err, 'Error message');
}

// ✅ GOOD - Always sanitize
catch (err) {
  req.log.error(sanitizeErrorForLogging(err), 'Error message');
}
```
- Always sanitize errors before logging:
```typescript
function sanitizeErrorForLogging(err: unknown): {
  error: string;
  stack?: string;
  name: string;
} {
  if (err instanceof Error) {
    return {
      error: err.message,
      stack: process.env.NODE_ENV === 'development' ? err.stack : undefined,
      name: err.name,
    };
  }
  return {
    error: String(err),
    name: 'UnknownError',
  };
}
```
- Use custom error classes instead of generic `Error` with string messages
- Always use type guards instead of `any` when checking error types:
```typescript
// ❌ BAD
if (err instanceof ZodError || (err as any)?.name === 'ZodError') { }

// ✅ GOOD
interface ErrorWithName extends Error {
  name: string;
}
function isZodError(err: unknown): err is ZodError {
  return (
    err instanceof ZodError ||
    (err !== null &&
      typeof err === 'object' &&
      'name' in err &&
      (err as ErrorWithName).name === 'ZodError')
  );
}
```

## TDD Workflow

```
1. Read test case from spec
2. Run test → RED (fails)
3. Implement minimum code → GREEN (passes)
4. Refactor → still GREEN
5. Move to next test
```

## Fastify-Specific Guidelines

### Architecture Principles
- Use modular architecture - one module per domain or main route
- Encapsulate routes in plugins (one route per HTTP resource)
- One handler per route that deals with business logic
- Use hooks (`onRequest`, `preHandler`, etc.) for request lifecycle management

### Validation
- **MANDATORY: All endpoints MUST have Fastify schema validation** - including query parameters, body, and params
- Validate input with JSON schemas and Fastify's built-in AJV validation
- Use DTOs or input types for handling structured data
- Prefer Fastify schema validation over manual Zod validation in handlers
- **Every route handler MUST define schema for all input parameters:**
```typescript
// ❌ BAD - No validation
fastify.get('/', controller.list.bind(controller));

// ✅ GOOD - Schema validation for query parameters
fastify.get('/', {
  schema: {
    querystring: {
      type: 'object',
      properties: {
        search: { type: 'string', maxLength: 100 },
        muscleGroup: { type: 'string', maxLength: 50 },
      },
    },
  },
}, controller.list.bind(controller));
```

### Route Registration Pattern
- Use async plugin functions for route modules
- Register routes with prefixes for organization
- Use `preHandler` for authentication and authorization

### Core Folder Structure
- `middleware/` - Common request handling (auth, validation)
- `core/` - Global error handlers, logging, instrumentation
- `utils/` - Utility functions used across the application
  - `error-utils.ts` - Shared error handling utilities (`isZodError`, `sanitizeErrorForLogging`)
- `errors/` - Custom error classes organized by domain
  - `auth.errors.ts` - Authentication-related errors
  - `workout.errors.ts` - Workout-related errors
  - One file per domain, export all error classes from that domain

### Environment Management
- Use environment variables for configuration
- Store sensitive information in `.env` (never commit)
- Use typed environment variable access
- **Always validate sensitive environment variables in production:**
```typescript
// Validate JWT_SECRET in production
if (process.env.NODE_ENV === 'production') {
  if (!process.env.JWT_SECRET) {
    throw new Error('JWT_SECRET environment variable is required in production');
  }
  if (JWT_SECRET === 'dev-secret') {
    throw new Error('JWT_SECRET cannot be "dev-secret" in production');
  }
  if (JWT_SECRET.length < JWT_SECRET_MIN_LENGTH) {
    throw new Error(`JWT_SECRET must be at least ${JWT_SECRET_MIN_LENGTH} characters`);
  }
}
```
- Extract default values to constants:
```typescript
// ❌ BAD
const JWT_SECRET = process.env.JWT_SECRET || 'dev-secret';

// ✅ GOOD
const DEFAULT_JWT_SECRET = 'dev-secret';
const JWT_SECRET = process.env.JWT_SECRET || DEFAULT_JWT_SECRET;
```

## Code Structure

### API Route Pattern

```typescript
// packages/backend/src/api/workouts/routes.ts
import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { WorkoutController } from './controller';
import { authMiddleware } from '../../middleware/auth.middleware';

export default async function workoutRoutes(
  fastify: FastifyInstance,
  options: FastifyPluginOptions
) {
  const controller = new WorkoutController();

  fastify.post('/', {
    preHandler: authMiddleware
  }, controller.create.bind(controller));

  fastify.get('/', {
    preHandler: authMiddleware
  }, controller.list.bind(controller));

  fastify.patch('/:id', {
    preHandler: authMiddleware
  }, controller.update.bind(controller));

  fastify.delete('/:id', {
    preHandler: authMiddleware
  }, controller.delete.bind(controller));
}
```

### Controller Pattern

```typescript
// packages/backend/src/api/workouts/controller.ts
import type { FastifyReply } from 'fastify';
import { WorkoutService } from '../../services/workout.service';
import { workoutSchema } from '@fitness/shared';
import { type AuthRequest } from '../../middleware/auth.middleware';
import { isZodError, sanitizeErrorForLogging } from '../../utils/error-utils';
import { InvalidWeightError, InvalidRepsError } from '../../errors/workout.errors';

export class WorkoutController {
  private service = new WorkoutService();
  
  /**
   * Creates a new workout
   * @param req - Fastify request with workout data
   * @param reply - Fastify reply
   * @returns 201 with workout data on success, 400/500 on error
   */
  async create(req: AuthRequest, reply: FastifyReply) {
    try {
      const validated = workoutSchema.parse(req.body || {});
      const result = await this.service.createWorkout(req.user!.userId, validated);
      return reply.status(201).send(result);
    } catch (err) {
      if (isZodError(err)) {
        return reply.status(400).send({ 
          error: 'Validation failed', 
          details: err.errors 
        });
      }
      if (err instanceof InvalidWeightError || err instanceof InvalidRepsError) {
        return reply.status(400).send({
          error: err.message,
        });
      }
      // Log sanitized error (no sensitive data)
      req.log.error(
        sanitizeErrorForLogging(err),
        'Unexpected error in create workout endpoint'
      );
      return reply.status(500).send({ error: 'Internal server error' });
    }
  }
}
```

**Critical Controller Rules:**
- **Always import error utilities from `utils/error-utils.ts`** - never duplicate `isZodError` or `sanitizeErrorForLogging`
- **MANDATORY: Always use `sanitizeErrorForLogging(err)` in catch blocks** - never log raw error objects
- **Always use `instanceof` for custom error classes** - never check error messages with string matching
- **Import `AuthRequest` from middleware** - don't redefine it in controllers
- **Every catch block MUST sanitize errors before logging:**
```typescript
// ❌ BAD
catch (err) {
  req.log.error(err, 'Error message');
}

// ✅ GOOD
catch (err) {
  req.log.error(sanitizeErrorForLogging(err), 'Error message');
}
```

### Service Pattern

```typescript
// packages/backend/src/services/workout.service.ts
import { WorkoutRepository } from '../repositories/workout.repository';
import type { WorkoutLog, WorkoutInput } from '@fitness/shared';
import { InvalidWeightError, InvalidRepsError } from '../errors/workout.errors';

export class WorkoutService {
  private repo = new WorkoutRepository();
  
  /**
   * Creates a new workout for a user
   * @param userId - User ID
   * @param data - Workout input data
   * @returns Created workout
   * @throws {InvalidWeightError} If weight is invalid
   * @throws {InvalidRepsError} If reps are invalid
   * @throws {Error} If database operation fails
   */
  async createWorkout(userId: string, data: WorkoutInput): Promise<WorkoutLog> {
    // Business validation
    if (data.weight <= 0) {
      throw new InvalidWeightError();
    }
    if (data.reps < 1 || data.reps > 100) {
      throw new InvalidRepsError();
    }
    
    return this.repo.create(userId, data);
  }
}
```

**Important Service Rules:**
- **Always use custom error classes** - never throw generic `Error` with string messages
- **Create error classes in `errors/` directory** - one file per domain (e.g., `workout.errors.ts`, `auth.errors.ts`)
- **Avoid race conditions**: Don't check existence before creating if DB has UNIQUE constraints. Let the database enforce uniqueness:
```typescript
// ❌ BAD - Race condition possible
const existing = await this.repo.findByEmail(email);
if (existing) throw new Error('Exists');
await this.repo.create(email, hash);

// ✅ GOOD - Database enforces uniqueness
try {
  await this.repo.create(email, hash);
} catch (error) {
  if (error instanceof Error && error.message.includes('UNIQUE constraint')) {
    throw new EmailAlreadyExistsError();
  }
  throw error;
}
```
- Always normalize user input (e.g., email to lowercase) before processing

### Repository Pattern

```typescript
// packages/backend/src/repositories/workout.repository.ts
export class WorkoutRepository {
  private db = DatabaseManager.getInstance();
  
  /**
   * Creates a new workout log entry
   * @param userId - User ID
   * @param data - Workout data
   * @returns Created workout log
   * @throws {Error} If database operation fails
   */
  async create(userId: string, data: WorkoutInput) {
    const id = crypto.randomUUID();
    try {
      this.db.prepare(`
        INSERT INTO workout_logs (id, user_id, exercise_id, weight, reps, sets, date)
        VALUES (?, ?, ?, ?, ?, ?, ?)
      `).run(id, userId, data.exerciseId, data.weight, data.reps, data.sets || 1, new Date().toISOString());
      
      return { id, ...data };
    } catch (error: unknown) {
      // Handle database errors properly
      if (
        error !== null &&
        typeof error === 'object' &&
        'code' in error &&
        String(error.code) === 'SQLITE_CONSTRAINT_UNIQUE'
      ) {
        throw new Error('Workout already exists');
      }
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      throw new Error(`Database error: ${errorMessage}`);
    }
  }
  
  /**
   * Finds a workout by ID
   * @param id - Workout ID
   * @returns Workout if found, null otherwise
   * @throws {Error} If database is not initialized (not null on missing table)
   */
  async findById(id: string): Promise<WorkoutLog | null> {
    try {
      const row = this.db.prepare('SELECT * FROM workout_logs WHERE id = ?').get(id);
      return row ? this.mapRowToWorkout(row) : null;
    } catch (error: unknown) {
      // Don't silently return null for configuration errors
      if (
        error !== null &&
        typeof error === 'object' &&
        'message' in error &&
        typeof error.message === 'string' &&
        error.message.includes('no such table')
      ) {
        throw new Error('Database not initialized. Run migrations first.');
      }
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      throw new Error(`Database error: ${errorMessage}`);
    }
  }
}
```

**Important Repository Rules:**
- **Never use `any` type** - use `unknown` and type guards
- **Don't silently return null for configuration errors** - throw descriptive errors
- Always handle UNIQUE constraint violations explicitly
- Use prepared statements (already enforced, but worth repeating)

## Validation Rules

| Field | Validation |
|-------|------------|
| `weight` | `> 0` |
| `reps` | `1-100` |
| `sets` | `1-10` |
| `rpe` | `1-10` |
| `exerciseId` | UUID format |

## Error Responses

```typescript
// 400 Bad Request
{ error: 'Validation failed', details: [...] }

// 401 Unauthorized
{ error: 'Unauthorized' }

// 404 Not Found
{ error: 'Workout not found' }

// 500 Internal Error
{ error: 'Internal server error' }
```

## Testing Requirements

### Testing Principles
- Follow Arrange-Act-Assert convention for tests
- Name test variables clearly: `inputX`, `mockX`, `actualX`, `expectedX`
- Write unit tests for each public function
- Use test doubles (mocks, stubs) to simulate dependencies
- Write acceptance tests for each module
- Follow Given-When-Then convention for integration tests

### Unit Test Example
```typescript
describe('WorkoutService', () => {
  it('should reject negative weight', async () => {
    const inputData = { weight: -10, reps: 5 };
    const userId = 'user1';
    
    await expect(service.createWorkout(userId, inputData))
      .rejects.toThrow('Weight must be positive');
  });
});
```

### Integration Test Example (Fastify inject)
```typescript
describe('POST /api/workouts', () => {
  it('should create with valid data', async () => {
    const response = await app.inject({
      method: 'POST',
      url: '/api/workouts',
      headers: {
        authorization: `Bearer ${token}`
      },
      payload: {
        exerciseId: 'ex1',
        weight: 100,
        reps: 5
      }
    });
    
    expect(response.statusCode).toBe(201);
    expect(JSON.parse(response.body)).toHaveProperty('id');
  });
});
```

### Health Check Route
- Create a `/health` route for health checks in each module
- Use for smoke tests and monitoring

## Database

- Use prepared statements (SQL injection prevention)
- WAL mode for concurrency
- Indexes on: `user_id`, `exercise_id`, `date`
- Foreign keys enabled

### SQL Query Best Practices

- **NEVER apply SQL functions to parameter placeholders** - apply functions to columns, normalize parameters in code:
```typescript
// ❌ BAD - LOWER(?) doesn't work in SQLite
query += ' AND LOWER(name) LIKE LOWER(?)';
params.push(`%${filters.search}%`);

// ✅ GOOD - Apply LOWER to column, normalize parameter in code
query += ' AND LOWER(name) LIKE ?';
params.push(`%${filters.search.toLowerCase()}%`);
```

- **Always normalize string parameters in code** before adding to SQL query:
  - Use `.toLowerCase()` for case-insensitive comparisons
  - Use `.trim()` to remove whitespace
  - Validate length before adding to query

- **Use parameterized queries for all user input** - never concatenate user input into SQL strings

## Common Issues and Solutions

### Issue 1: Using Generic Error Instead of Custom Error Classes

**Problem:**
```typescript
// ❌ BAD
if (data.weight <= 0) {
  throw new Error('Weight must be positive');
}
```

**Solution:**
```typescript
// ✅ GOOD
// 1. Create error class in errors/workout.errors.ts
export class InvalidWeightError extends Error {
  constructor(message = 'Weight must be positive') {
    super(message);
    this.name = 'InvalidWeightError';
  }
}

// 2. Use in service
import { InvalidWeightError } from '../errors/workout.errors';
if (data.weight <= 0) {
  throw new InvalidWeightError();
}

// 3. Check with instanceof in controller
if (err instanceof InvalidWeightError) {
  return reply.status(400).send({ error: err.message });
}
```

### Issue 2: Duplicating Error Utilities Across Controllers

**Problem:**
```typescript
// ❌ BAD - Duplicated in every controller
function isZodError(err: unknown): err is ZodError { ... }
function sanitizeErrorForLogging(err: unknown) { ... }
```

**Solution:**
```typescript
// ✅ GOOD
// 1. Create utils/error-utils.ts with shared utilities
import { ZodError } from 'zod';

interface ErrorWithName extends Error {
  name: string;
}

export function isZodError(err: unknown): err is ZodError {
  return (
    err instanceof ZodError ||
    (err !== null &&
      typeof err === 'object' &&
      'name' in err &&
      (err as ErrorWithName).name === 'ZodError')
  );
}

export function sanitizeErrorForLogging(err: unknown): {
  error: string;
  stack?: string;
  name: string;
} {
  if (err instanceof Error) {
    return {
      error: err.message,
      stack: process.env.NODE_ENV === 'development' ? err.stack : undefined,
      name: err.name,
    };
  }
  return {
    error: String(err),
    name: 'UnknownError',
  };
}

// 2. Import in controllers
import { isZodError, sanitizeErrorForLogging } from '../../utils/error-utils';
```

### Issue 3: Checking Error Messages Instead of Error Types

**Problem:**
```typescript
// ❌ BAD - Fragile, breaks if message changes
if (err instanceof Error && err.message.includes('must be')) {
  return reply.status(400).send({ error: err.message });
}
```

**Solution:**
```typescript
// ✅ GOOD - Type-safe, robust
if (err instanceof InvalidWeightError || err instanceof InvalidRepsError) {
  return reply.status(400).send({ error: err.message });
}
```

### Issue 4: Forgetting to Register Routes in index.ts

**Problem:**
```typescript
// ❌ BAD - Routes created but not registered
// await app.register(workoutRoutes, { prefix: '/api/workouts' });
```

**Solution:**
```typescript
// ✅ GOOD - Always register new routes
import workoutRoutes from './api/workouts/routes.js';
await app.register(workoutRoutes, { prefix: '/api/workouts' });
```

**Checklist before committing:**
- [ ] All new routes are imported in `index.ts`
- [ ] All routes are registered with `app.register()`
- [ ] Route prefixes match API specification

### Issue 5: Redefining Types Already Defined Elsewhere

**Problem:**
```typescript
// ❌ BAD - AuthRequest redefined in every controller
interface AuthRequest extends FastifyRequest {
  user?: { userId: string; email: string };
}
```

**Solution:**
```typescript
// ✅ GOOD - Import from middleware
import { type AuthRequest } from '../../middleware/auth.middleware';
```

### Issue 6: Incorrect SQL Function Usage with Parameters

**Problem:**
```typescript
// ❌ BAD - LOWER(?) doesn't work - SQL functions can't be applied to placeholders
query += ' AND LOWER(name) LIKE LOWER(?)';
params.push(`%${filters.search}%`);
```

**Solution:**
```typescript
// ✅ GOOD - Apply LOWER to column, normalize parameter in code
query += ' AND LOWER(name) LIKE ?';
params.push(`%${filters.search.toLowerCase()}%`);
```

**Rule:** Always apply SQL functions (LOWER, UPPER, TRIM, etc.) to columns, not to parameter placeholders. Normalize string parameters in JavaScript/TypeScript code before adding them to the query.

### Issue 7: Missing Error Sanitization in Catch Blocks

**Problem:**
```typescript
// ❌ BAD - Security risk: raw error may contain sensitive data
catch (err) {
  req.log.error(err, 'Unexpected error in endpoint');
  return reply.status(500).send({ error: 'Internal server error' });
}
```

**Solution:**
```typescript
// ✅ GOOD - Always sanitize errors before logging
import { sanitizeErrorForLogging } from '../../utils/error-utils.js';

catch (err) {
  req.log.error(
    sanitizeErrorForLogging(err),
    'Unexpected error in endpoint'
  );
  return reply.status(500).send({ error: 'Internal server error' });
}
```

**Rule:** NEVER log raw error objects. Always use `sanitizeErrorForLogging` to prevent leaking sensitive data (passwords, tokens, stack traces).

### Issue 8: Missing Query Parameter Validation

**Problem:**
```typescript
// ❌ BAD - No validation for query parameters
fastify.get('/', controller.list.bind(controller));
```

**Solution:**
```typescript
// ✅ GOOD - Always validate query parameters with Fastify schema
fastify.get('/', {
  schema: {
    querystring: {
      type: 'object',
      properties: {
        search: { type: 'string', maxLength: 100 },
        muscleGroup: { type: 'string', maxLength: 50 },
      },
    },
  },
}, controller.list.bind(controller));
```

**Rule:** All endpoints MUST have Fastify schema validation for all input parameters (querystring, body, params).

## Anti-patterns

❌ Business logic in controller  
❌ Direct database access from controller  
❌ Tests after implementation  
❌ Hardcoded values instead of constants  
❌ Missing error handling
❌ Logging raw error objects (security risk)
❌ Using `any` type for error handling
❌ Race conditions from check-then-act patterns
❌ Returning null for configuration errors (should throw)
❌ Missing JSDoc for public methods
❌ Missing validation schemas for all endpoints
❌ Using generic `Error` instead of custom error classes
❌ Duplicating utility functions across files
❌ Checking error messages with string matching instead of `instanceof`
❌ Forgetting to register routes in `index.ts`
❌ Redefining types that already exist in shared modules
❌ Applying SQL functions to parameter placeholders (e.g., `LOWER(?)`)
❌ Unused variables in code
❌ Missing Fastify schema validation for query parameters

## Code Review Checklist

Before submitting code, verify:
- [ ] All catch blocks use `sanitizeErrorForLogging(err)` instead of logging raw errors
- [ ] All routes have Fastify schema validation (querystring, body, params)
- [ ] SQL queries apply functions to columns, not parameter placeholders
- [ ] String parameters are normalized (toLowerCase, trim) in code before SQL queries
- [ ] No unused variables or imports
- [ ] All error handling follows the controller pattern with proper error types
- [ ] All routes are registered in `index.ts`
